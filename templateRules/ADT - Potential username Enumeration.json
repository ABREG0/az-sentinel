{
  "MicrosoftSecurityIncidentCreation": [],
  "Scheduled": [
    {
        "severity": "Medium",
        "query": "let lookback = 1d; \r\nlet FailedLogonMin = 3; \r\nlet UserNameMatchMin = 2;\r\nlet upnFunc = (startTimeSpan:timespan, tableName:string){ \r\ntable(tableName) | where TimeGenerated >= ago(lookback)\r\n| extend Operation = columnifexists(\"Operation\", \"Sign-in activity\")\r\n| where Operation == \"UserLoginFailed\" or Operation == \"Sign-in activity\"\r\n| extend Result = columnifexists(\"ResultType\", \"tempValue\")\r\n| extend Result = iff(Result == \"tempValue\", columnifexists(\"ResultStatus\", Result), Result)\r\n| extend ResultValue = case(Result == \"0\", \"Success\", Result == \"Success\" or Result == \"Succeeded\", \"Success\", Result)\r\n| where ResultValue != \"Success\"\r\n| extend UserPrincipalName = columnifexists(\"UserPrincipalName\", \"tempValue\") \r\n| extend UserPrincipalName = iff(tableName == \"OfficeActivity\", tolower(UserId), tolower(UserPrincipalName)) \r\n| extend UPN = split(UserPrincipalName, \"@\") \r\n| extend UserNameOnly = tostring(UPN[0]) \r\n| extend DomainOnly = tostring(UPN[1]) \r\n| where UserNameOnly contains \".\" or UserPrincipalName contains \"-\" or UserPrincipalName contains \"_\" \r\n// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators \r\n// Count of any that are not alphanumeric \r\n| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', \"regex\") \r\n// Drop any that have non-alphanumeric characters still included \r\n| where charcount < 2 \r\n// Creating array of name pairs that include the separators we are interested in, this can be added to if needed. \r\n| extend unoArray = case( \r\nUserNameOnly contains \".\", split(UserNameOnly, \".\"), \r\nUserNameOnly contains \"-\", split(UserNameOnly, \"-\"), \r\nUserNameOnly contains \"_\", split(UserNameOnly, \"_\"), \r\nUserNameOnly \r\n) \r\n| extend First = iff(isnotempty(tostring(parsejson(unoArray)[0])), tostring(parsejson(unoArray)[0]),tostring(unoArray)) \r\n| extend Last = tostring(parsejson(unoArray)[1]) \r\n| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(First, 0,4), \"LessThan4\") \r\n| extend First6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(First, 0,6), \"LessThan6\") \r\n| extend First8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(First, 0,8), \"LessThan8\") \r\n| extend Last4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(Last, 0,4), \"LessThan4\") \r\n| extend Last6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(Last, 0,6), \"LessThan6\") \r\n| extend Last8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(Last, 0,8), \"LessThan8\") \r\n| where First != Last \r\n| summarize UserNames = makeset(UserNameOnly), FailedLogonCount = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type \r\n}; \r\nlet SigninList = upnFunc(lookback,\"SigninLogs\"); \r\nlet OffActList = upnFunc(lookback,\"OfficeActivity\"); \r\nlet UserNameList = (union isfuzzy=true SigninList, OffActList);\r\nlet Char4List = UserNameList \r\n| project TimeGenerated, First4char, Last4char, UserNames, FailedLogonCount, Type \r\n| where First4char != \"LessThan4\" and Last4char != \"LessThan4\"; \r\n// Break out first and last so we can then join and see where a first and last match. \r\nlet First4charList = Char4List | where isnotempty(First4char) | summarize UserNameMatchOnFirst = makeset(UserNames), FailedLogonCountForFirst = sum(FailedLogonCount) by TimeGenerated, CharSet = First4char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnFirst, UserNameMatchOnFirstCount = array_length(UserNameMatchOnFirst), FailedLogonCountForFirst, Type; \r\nlet Last4charList = Char4List | where isnotempty(Last4char) | summarize UserNameMatchOnLast = makeset(UserNames), FailedLogonCountForLast = sum(FailedLogonCount) by TimeGenerated, CharSet = Last4char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnLast, UserNameMatchOnLastCount = array_length(UserNameMatchOnLast), FailedLogonCountForLast, Type; \r\nlet char4 = First4charList | join ( \r\nLast4charList  \r\n) on $left.CharSet == $right.CharSet and $left.TimeGenerated == $right.TimeGenerated \r\n| project-away TimeGenerated1, CharSet1 \r\n// Make sure that we get more than a single match for First or Last\r\n| where UserNameMatchOnFirstCount >= UserNameMatchMin or UserNameMatchOnLastCount >= UserNameMatchMin\r\n| where FailedLogonCountForFirst >= FailedLogonMin or FailedLogonCountForLast >= FailedLogonMin\r\n; \r\nlet Char6List = UserNameList  \r\n| project TimeGenerated, First6char, Last6char, UserNames, FailedLogonCount, Type \r\n| where First6char != \"LessThan6\" and Last6char != \"LessThan6\"; \r\n// Break out first and last so we can then join and see where a first and last match. \r\nlet First6charList = Char6List | where isnotempty(First6char) | summarize UserNameMatchOnFirst = makeset(UserNames), FailedLogonCountForFirst = sum(FailedLogonCount) by TimeGenerated, CharSet = First6char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnFirst, UserNameMatchOnFirstCount = array_length(UserNameMatchOnFirst), FailedLogonCountForFirst, Type; \r\nlet Last6charList = Char6List | where isnotempty(Last6char) | summarize UserNameMatchOnLast = makeset(UserNames), FailedLogonCountForLast = sum(FailedLogonCount) by TimeGenerated, CharSet = Last6char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnLast, UserNameMatchOnLastCount = array_length(UserNameMatchOnLast), FailedLogonCountForLast, Type; \r\nlet char6 = First6charList | join ( \r\nLast6charList  \r\n) on $left.CharSet == $right.CharSet and $left.TimeGenerated == $right.TimeGenerated \r\n| project-away TimeGenerated1, CharSet1\r\n// Make sure that we get more than a single match for First or Last\r\n| where UserNameMatchOnFirstCount >= UserNameMatchMin or UserNameMatchOnLastCount >= UserNameMatchMin\r\n| where FailedLogonCountForFirst >= FailedLogonMin or FailedLogonCountForLast >= FailedLogonMin\r\n; \r\nlet Char8List = UserNameList  \r\n| project TimeGenerated, First8char, Last8char, UserNames, FailedLogonCount, Type \r\n| where First8char != \"LessThan8\" and Last8char != \"LessThan8\"; \r\n// Break out first and last so we can then join and see where a first and last match. \r\nlet First8charList = Char8List | where isnotempty(First8char) | summarize UserNameMatchOnFirst = makeset(UserNames), FailedLogonCountForFirst = sum(FailedLogonCount) by TimeGenerated, CharSet = First8char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnFirst, UserNameMatchOnFirstCount = array_length(UserNameMatchOnFirst), FailedLogonCountForFirst, Type; \r\nlet Last8charList = Char8List | where isnotempty(Last8char) | summarize UserNameMatchOnLast = makeset(UserNames), FailedLogonCountForLast = sum(FailedLogonCount) by TimeGenerated, CharSet = Last8char, Type\r\n| project TimeGenerated, CharSet, UserNameMatchOnLast, UserNameMatchOnLastCount = array_length(UserNameMatchOnLast), FailedLogonCountForLast, Type; \r\nlet char8 = First8charList | join ( \r\nLast8charList  \r\n) on $left.CharSet == $right.CharSet and $left.TimeGenerated == $right.TimeGenerated \r\n| project-away TimeGenerated1, CharSet1 \r\n// Make sure that we get more than a single match for First or Last\r\n| where UserNameMatchOnFirstCount >= UserNameMatchMin or UserNameMatchOnLastCount >= UserNameMatchMin\r\n| where FailedLogonCountForFirst >= FailedLogonMin or FailedLogonCountForLast >= FailedLogonMin\r\n; \r\n(union isfuzzy=true char4, char6, char8) \r\n| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst, UserNameMatchOnFirstCount, FailedLogonCountForFirst, UserNameMatchOnLast, UserNameMatchOnLastCount, FailedLogonCountForLast \r\n| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc\r\n| extend timestamp = TimeGenerated",
        "queryFrequency": "PT5H",
        "queryPeriod": "PT5H",
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "suppressionDuration": "PT5H",
        "suppressionEnabled": false,
        "eventGroupingSettings": {
          "aggregationKind": "SingleAlert"
        },
        "displayName": "ADT - Potential username Enumeration 1",
        "enabled": true,
        "description": "ADT - Potential username Enumeration 1",
        "tactics": [
          "InitialAccess",
          "CredentialAccess"
        ],
        "kind": "Scheduled",
        "createIncident": true,
        "groupingConfiguration": {
          "enabled": false,
          "reopenClosedIncident": false,
          "lookbackDuration": "PT5H",
          "entitiesMatchingMethod": "All",
          "groupByEntities": []
        },
        "playbookName": ""
      }
  ]
}
